# -*- coding: utf-8 -*-
"""game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zvddbNWWpSJYXcAadWXVuqEp1b42d-1T
"""

# ===================== 4×4×4 立体四目・ビットボード版（命名統一） =====================
from __future__ import annotations
from dataclasses import dataclass
from typing import List
import random, math

SIZE        = 4
BOARD_SIZE  = SIZE ** 3                 # 64
ALL_MASK    = (1 << BOARD_SIZE) - 1     # 0xffff_ffff_ffff_ffff

# --- 3D → 1D インデックスとビット -----------------
def idx(x: int, y: int, z: int) -> int: return x + y*SIZE + z*SIZE*SIZE
def BIT(x: int, y: int, z: int) -> int: return 1 << idx(x, y, z)

# --- 76 本の勝利ライン --------------------------------
def make_lines76() -> List[int]:
    r, L = range(SIZE), []
    # 軸方向
    for y in r:
        for z in r: L.append(sum(BIT(x,y,z) for x in r))
    for x in r:
        for z in r: L.append(sum(BIT(x,y,z) for y in r))
    for x in r:
        for y in r: L.append(sum(BIT(x,y,z) for z in r))
    # 平面斜め
    for z in r:
        L += [sum(BIT(i,i,z)          for i in r),
              sum(BIT(SIZE-1-i,i,z)   for i in r)]
    for y in r:
        L += [sum(BIT(i,y,i)          for i in r),
              sum(BIT(SIZE-1-i,y,i)   for i in r)]
    for x in r:
        L += [sum(BIT(x,i,i)          for i in r),
              sum(BIT(x,SIZE-1-i,i)   for i in r)]
    # 空間斜め
    L += [sum(BIT(i,i,i)              for i in r),
          sum(BIT(SIZE-1-i,i,i)       for i in r),
          sum(BIT(i,SIZE-1-i,i)       for i in r),
          sum(BIT(SIZE-1-i,SIZE-1-i,i)for i in r)]
    assert len(L) == 76
    return L

LINES76 = make_lines76()

# --------------------------------------------------------------------
@dataclass
class State:
    pieces:        int = 0  # 現手番の石
    enemy_pieces:  int = 0  # 相手の石

    # ---- 基本 ----
    @staticmethod
    def pop(bits:int)->int: return bits.bit_count()
    def turn(self)->int:    return self.pop(self.pieces|self.enemy_pieces)+1
    def is_first_player(self)->bool: return self.pop(self.pieces)==self.pop(self.enemy_pieces)

    # ---- 勝敗 ----
    def _is_win(self, bits:int)->bool:
        return any((bits & line)==line for line in LINES76)
    def is_win (self)->bool: return self._is_win(self.pieces)
    def is_lose(self)->bool: return self._is_win(self.enemy_pieces)
    def is_draw(self)->bool: return (self.pieces|self.enemy_pieces)==ALL_MASK
    def is_done (self)->bool: return self.is_win() or self.is_lose() or self.is_draw()

    # ---- 合法手（重力）----
    def legal_actions(self)->List[int]:
        acts, occ = [], self.pieces|self.enemy_pieces
        for x in range(SIZE):
            for y in range(SIZE):
                for z in range(SIZE):          # 下から探索
                    i = idx(x,y,z)
                    if not (occ>>i & 1):
                        acts.append(i); break
        return acts

    # ---- 手を打つ ----

    def next_from_index(self, i) -> "State":
        i = int(i)                     # ★ここを追加（numpy.int64 → int）
        assert not ((self.pieces | self.enemy_pieces) >> i & 1), "occupied"
        return State(self.enemy_pieces, self.pieces | (1 << i))


    def place(self, x:int, y:int)->"State":
        for z in range(SIZE):
            i = idx(x,y,z)
            if not ((self.pieces|self.enemy_pieces)>>i & 1):
                return self.next_from_index(i)
        raise ValueError("column full")

    # ---- 表示 ----
    def __str__(self)->str:
        ox = ('o','x') if self.is_first_player() else ('x','o')
        head = "   " + "   ".join(f"z={z}" for z in range(SIZE))
        rows=[head]
        for y in range(SIZE-1,-1,-1):
            line=[]
            for z in range(SIZE):
                s=[]
                for x in range(SIZE):
                    b=BIT(x,y,z)
                    s.append(ox[0] if self.pieces & b else
                             ox[1] if self.enemy_pieces & b else '-')
                line.append("".join(s))
            rows.append("   ".join(line))
        return "\n".join(rows)

    # ---- ライン評価 (+自分, -相手) ----
    def line_counts(self)->List[int]:
        out=[]
        for line in LINES76:
            if (self.pieces & line) and (self.enemy_pieces & line): out.append(0)
            elif self.pieces & line:  out.append(self.pop(self.pieces & line))
            else:                     out.append(-self.pop(self.enemy_pieces & line))
        return out

# ---------------- ランダム手 ----------------
def random_action(state: State) -> int:
    """合法手（セル index 0-63）の中から 1 手ランダムに返す"""
    return random.choice(state.legal_actions())

# ---------------- プレイアウト ----------------
def playout(state: State) -> int:
    """
      終局まで双方ランダムに打ち進め、
      先手視点で  win:+1 / draw:0 / lose:-1 を返す
    """
    while not state.is_done():
        state = state.next_from_index(random_action(state))
    return 1 if state.is_win() else -1 if state.is_lose() else 0

# ---------------- MCTS で行動選択 ----------------
def mcts_action(state: State, rollouts: int = 1000) -> int:
    """MCTS で bestMove を返す（戻り値はセル index）"""

    class Node:
        __slots__ = ("state", "w", "n", "children")
        def __init__(self, state: State):
            self.state    = state   # 盤面
            self.w        = 0       # 累計価値
            self.n        = 0       # 試行回数
            self.children = None    # 子ノード list[Node] | None

        # -------- ノード評価 --------
        def evaluate(self) -> float:
            # 1) 終局なら価値を返す
            if self.state.is_done():
                value =  1 if self.state.is_win()  else \
                        -1 if self.state.is_lose() else 0
                self.w += value; self.n += 1
                return value

            # 2-a) 未展開ならプレイアウト
            if self.children is None:
                value = playout(self.state)
                self.w += value; self.n += 1
                if self.n == 10:                      # 展開閾値
                    self.expand()
                return value

            # 2-b) 展開済みなら UCB1 で子を選択
            value = -self.best_child().evaluate()
            self.w += value; self.n += 1
            return value

        # -------- 子展開 --------
        def expand(self):
            self.children = [
                Node(self.state.next_from_index(i))
                for i in self.state.legal_actions()
            ]

        # -------- UCB1 で子を選ぶ --------
        def best_child(self) -> "Node":
            # まず未訪問ノード優先
            for c in self.children:
                if c.n == 0:
                    return c

            total = sum(c.n for c in self.children)
            C     = 2.0                               # 探索定数
            ucb_values = [
                -c.w / c.n + C * math.sqrt(math.log(total) / c.n)
                for c in self.children
            ]
            return self.children[ucb_values.index(max(ucb_values))]

    # -------- MCTS 開始 --------
    root = Node(state)
    root.expand()

    for _ in range(rollouts):
        root.evaluate()

    # -------- 試行回数最大の手を選択 --------
    counts = [c.n for c in root.children]
    best   = root.state.legal_actions()[counts.index(max(counts))]
    return best

if __name__ == "__main__":
    s = State()
    while not s.is_done():
        move = mcts_action(s, rollouts=500)   # ← MCTS が返すセル index
        s     = s.next_from_index(move)
        print(s, "\n")