# -*- coding: utf-8 -*-
"""pv_mcts.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19kXlPiWlrazXHC1ACIYuuS0wvxTRhbkl
"""

# =============================================================
# pv_mcts_bitboard.py   4×4×4 立体四目  ― ビットボード版 MCTS
# =============================================================
from pathlib import Path
from math import sqrt
import numpy as np
from tensorflow.keras.models import load_model

from game          import State
from dual_network  import DN_INPUT_SHAPE            # (4,4,8)


# -------------------- 定数 --------------------
PV_EVALUATE_COUNT = 50          # 1 盤面あたりシミュレーション数
MAX_BATCH         = 32          # たまった葉ノードがこの数を超えたらまとめて推論
SIZE = DN_INPUT_SHAPE[0]        # 4
CHAN = DN_INPUT_SHAPE[2]        # 8 (= SIZE*2)

# -------------------------------------------------------------
# 盤面エンコード (State → (1,4,4,8))
# -------------------------------------------------------------
def encode_state(state: State) -> np.ndarray:
    planes = np.zeros(DN_INPUT_SHAPE, dtype=np.float32)

    mine = np.unpackbits(
        np.array([state.pieces], dtype=np.uint64).view(np.uint8),
        bitorder="little"
    ).reshape(SIZE, SIZE, SIZE)                  # (z,y,x)

    yours = np.unpackbits(
        np.array([state.enemy_pieces], dtype=np.uint64).view(np.uint8),
        bitorder="little"
    ).reshape(SIZE, SIZE, SIZE)

    # (z,y,x) → (y,x,z)
    planes[..., :SIZE]  = mine.transpose(1, 2, 0)   # 自分  ch 0-3
    planes[..., SIZE:] = yours.transpose(1, 2, 0)   # 相手  ch 4-7
    return planes[np.newaxis]                       # (1,4,4,8)

# -------------------------------------------------------------
# ボルツマン分布
# -------------------------------------------------------------
def boltzmann(xs, temperature: float):
    xs = np.asarray(xs, dtype=np.float32)
    xs = np.power(xs, 1.0 / temperature)
    xs /= xs.sum()
    return xs

# -------------------------------------------------------------
# MCTS 本体
# -------------------------------------------------------------
def pv_mcts_scores(model, state: State, temperature: float):
    """局面 state に対して MCTS を行い，合法手確率を返す"""

    # ---- バッチ推論用バッファ ----
    leaf_states: list[np.ndarray] = []
    leaf_nodes:  list["Node"]     = []

    class Node:
        __slots__ = ("state", "p", "w", "n", "children")

        def __init__(self, state: State, p: float):
            self.state    = state
            self.p        = p          # 事前確率
            self.w        = 0.0        # 累計価値
            self.n        = 0          # 訪問回数
            self.children = None       # list[Node] | None

        # ---------- 子ノード展開 ----------
        def expand_with_nn_output(self, p_logits: np.ndarray, value: float):
            self.w += value
            self.n += 1

            legal = self.state.legal_actions()
            probs = p_logits[[idx % 16 for idx in legal]]
            s     = probs.sum()
            probs = probs / s if s else np.full_like(probs, 1.0 / len(probs))

            self.children = [Node(self.state.next_from_index(idx), float(prob))
                             for idx, prob in zip(legal, probs)]

        # ---------- 評価 ----------
        def evaluate(self) -> float:
            # 1) 終局
            if self.state.is_done():
                value =  1 if self.state.is_win()  else \
                        -1 if self.state.is_lose() else 0
                self.w += value
                self.n += 1
                return value

            # 2) 未展開：バッファに追加して仮の 0 を返す
            if self.children is None:
                leaf_states.append(encode_state(self.state))
                leaf_nodes.append(self)
                return 0.0

            # 3) 展開済み：子を選んで再帰
            value = -self.select_child().evaluate()
            self.w += value
            self.n += 1
            return value

        # ---------- 子選択 (PUCT) ----------
        def select_child(self):
            C_PUCT  = 1.0
            total_n = max(1, sum(c.n for c in self.children))
            scores = [(-c.w / c.n if c.n else 0.0) +
                      C_PUCT * c.p * sqrt(total_n) / (1 + c.n)
                      for c in self.children]
            return self.children[int(np.argmax(scores))]

    # ===== ルートノード =====
    root = Node(state, p=0.0)

    # ===== シミュレーション =====
    for sim in range(PV_EVALUATE_COUNT):
        root.evaluate()

        # 葉ノードがたまったら一括推論
        if sim == 0 or len(leaf_states) >= MAX_BATCH or sim == PV_EVALUATE_COUNT - 1:
            if leaf_states:
                batch = np.concatenate(leaf_states, axis=0)          # (k,4,4,8)
                p_logits, v_preds = model.predict(batch,
                                                  batch_size=len(batch),
                                                  verbose=0)
                for node, logit, v in zip(leaf_nodes, p_logits, v_preds):
                    node.expand_with_nn_output(logit, float(v))

                leaf_states.clear()
                leaf_nodes.clear()

    # ===== 訪問回数 → 行動確率 =====
    visits = np.array([c.n for c in root.children], dtype=np.float32)

    probs = (np.zeros_like(visits) if temperature == 0
             else boltzmann(visits, temperature))
    if temperature == 0:
        probs[np.argmax(visits)] = 1.0

    return probs

# -------------------------------------------------------------
# 行動選択ラッパ
# -------------------------------------------------------------
def pv_mcts_action(model, temperature: float = 0):
    def act(state: State):
        probs  = pv_mcts_scores(model, state, temperature)
        action = int(np.random.choice(state.legal_actions(), p=probs))
        return action
    return act

# ----------------------- 動作確認 -----------------------------
if __name__ == "__main__":
    if not Path("./model/best.h5").exists():
        from dual_network import dual_network
        dual_network()
    model = load_model("./model/best.h5", compile=False)

    s = State()
    next_act = pv_mcts_action(model, temperature=1.0)

    while not s.is_done():
        s = s.next_from_index(next_act(s))
        print(s, "\n")