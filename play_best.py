# -*- coding: utf-8 -*-
"""play_best.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19VOgYtV654vqdFP4rHGW-RDBojDYCJhK
"""

# Commented out IPython magic to ensure Python compatibility.
import os, json, time, shutil
from pathlib import Path
from google.colab import drive
from tensorflow.keras import backend as K

# ---------- 0) Google Drive ----------
drive.mount('/content/drive', force_remount=False)

ROOT = Path('/content/drive/MyDrive/azero_3d')
MODEL_DIR = ROOT / 'model'
DATA_DIR  = ROOT / 'data'
MODEL_DIR.mkdir(parents=True, exist_ok=True)
DATA_DIR.mkdir(exist_ok=True)

# ---------- 1) コード置き場に移動 ----------
# %cd /content/drive/MyDrive/sample/3dyonnmoku/train_code_new
import sys; sys.path.append(os.getcwd())

# play_best.py
"""
人間 vs best.h5 （PV-MCTS 800 シミュレーション）対局 UI
--------------------------------------------------------
実行方法:  python play_best.py
"""

import sys, random
from pathlib import Path
from tensorflow.keras.models import load_model
from pv_mcts import pv_mcts_action
from typing import List

# ===== 盤面クラス =====
# 先ほどの State をそのままインポート
from game import State, SIZE, idx

# ====== best.h5 をロードし、推論関数を作る ======
BEST_PATH = Path("/content/drive/MyDrive/azero_3d/model/best.h5")
if not BEST_PATH.exists():
    sys.exit("❌ best.h5 が見つかりません。学習 or コピー後に再実行してください。")

print("📂 loading model ...", end="", flush=True)
model = load_model(BEST_PATH, compile=False)

ai_policy_value = pv_mcts_action(model, temperature = 0, num_simulations = 2000, add_noise = False)   # 推論関数 (= State→int)
print(" done.\n")
# ===================== ヘルプ文字列 =====================
def print_help():
    print("  - x y : あなたの手 (例 1 2)")
    print("  - undo / u / 待った : 直前の AI 手 + あなたの 1 手を取り消し")
    print("  - quit / exit : 終了\n")

# ===================== 追加：定石ユーティリティ =====================
JOSEKI_PARALLEL = [(0,0), (3,3), (0,3), (3,0)]  # x,y   ※z は重力で自動決定

def apply_joseki(state: State, moves=JOSEKI_PARALLEL) -> State:
    """
    与えられた (x,y) リストを先頭から順に打ち込む。
    gravity 付きなので最も低い z に石が入る。
    奇数番目＝先手、偶数番目＝後手として自動で pieces/enemy_pieces を反転。
    """
    for x,y in moves:
        # State.place は「現手番」側が打つ → player swap 済み state が帰る
        state = state.place(x,y)
    return state

# ------------------------------------------------------------------
def human_action(state: State) -> int:
    """x y 入力を z=0 起点で下から探索"""
    while True:
        try:
            raw = input("あなたの手 (x y) → ").strip()
            if raw.lower() in ("quit", "exit"): sys.exit(0)
            x, y = map(int, raw.split())
            if not (0 <= x < SIZE and 0 <= y < SIZE):
                raise ValueError
        except ValueError:
            print("入力は 0–3 の整数 2 つです。例: 1 2")
            continue

        for z in range(SIZE):
            i = idx(x, y, z)          # staticmethod を直接呼べる
            if (state.pieces | state.enemy_pieces) >> i & 1 == 0:
                return i
        print("その列は満杯です。別の列を選んでください。")

# ------------------------------------------------------------------
def game_loop():
    # --- 先手・後手の選択 -----------------------------------------
    while True:
        ans = input("先手でプレイしますか？ (y/n) → ").strip().lower()
        if ans in ("y", "yes"):  human_first = True;  break
        if ans in ("n", "no"):   human_first = False; break
        print("y か n で答えてください。")

    state = State()
    # --- 定石を使うか確認 ------------------------------------------
    ans = input("最初に並行定石 0 0-3 3-0 3-3 0 を適用しますか？ (y/n) → ").strip().lower()
    use_joseki = ans in ("y", "yes")

    state = State()
    if use_joseki:
        state = apply_joseki(state)
    print("\n=== 立体四目（PV-MCTS 付き best.h5）===")
    if human_first:
        print("[あなた] 先手  /  [AI] 後手")
    else:
        print("[AI] 先手  /  [あなた] 後手")
    print(state, "\n")

    # ---------- 盤面履歴（待った用） ----------
    history: List[State] = [state]     # 現在の盤面を常に末尾に保持

    # --- メインループ ---------------------------------------------
    while not state.is_done():
        human_turn = (state.is_first_player() and human_first) or \
                     (not state.is_first_player() and not human_first)

        if human_turn:
            # ---------- 人間入力 ----------
            while True:
                raw = input("あなたの手 (x y / undo / help) → ").strip().lower()

                # --- undo -----------------
                if raw in ("undo", "u", "待った"):
                    if len(history) <= 1:
                        print("⚠ これ以上戻れません")
                        continue
                    # 直前 AI 手 & あなたの手を取り消し
                    history.pop()              # = 直前 AI 手
                    if len(history) > 1:
                        history.pop()          # = あなたの前回手
                    state = history[-1]
                    print(state, "\n(待ったしました。あなたの番です)")
                    continue      # 再度入力待ち

                # --- help -----------------
                if raw in ("h", "help", "?"):
                    print_help(); continue

                # --- quit -----------------
                if raw in ("quit", "exit"):
                    raise SystemExit

                # --- 座標入力 ---------------
                try:
                    x, y = map(int, raw.split())
                    move = None
                    for z in range(SIZE):
                        i = idx(x, y, z)
                        if (state.pieces | state.enemy_pieces) >> i & 1 == 0:
                            move = i; break
                    if move is None:
                        print("その列は満杯です。")
                        continue
                    break
                except Exception:
                    print("形式エラー: 0–3 の整数 2 つを入力")
                    continue

            print("\nあなたの手:")
        else:
            move = ai_policy_value(state)  # ← best.h5 + PV-MCTS
            print("AI の手:", f"({move%SIZE}, {(move//SIZE)%SIZE}) z?")

        state = state.next_from_index(move)
        history.append(state)
        print(state, "\n")

    # --- 勝敗判定 --------------------------------------------------
    if state.is_draw():
        print("引き分け。")
    else:
        winner_is_human = human_turn  # 最後に指した側が勝ち
        print("あなたの勝ち！🎉" if winner_is_human else "AI の勝ち…💦")

# ------------------------------------------------------------------
if __name__ == "__main__":
    try:
        game_loop()
    except KeyboardInterrupt:
        print("\n強制終了しました。")